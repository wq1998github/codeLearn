# Makefile
## 一、Makefile简介
### 1. make工具
   + make是一个工程管理工具，能帮我们实现项目的自动编译
   + 在C语言中，只有源文件 ( *.c文件 ) 才会参与编译。当只有某些文件做了修改的时候，重新编译整个项目是一种非常不可取的做法(浪费时间)。我们需要一种方式，**能自动帮我们判断出哪些文件做了修改，哪些文件需要重新编译，以及哪些文件需要先编译，哪些文件需要后编译**，Makefile就能够帮助我们完成这个任务
   + Makefile仅仅是一个文件，里面写了很多的规则，这些规则用来说明如何编译以及编译的顺序
   + Makefile中制定的规则，会由make这个命令行工具来执行
   + Makefile与make的关系可以大致理解为shell脚本与shell的关系

### 2. make工具的功能
> + 主要负责一个软件工程中多个源代码的自动编译工作
> + 还能进行环境检测、后期处理等工作
> + make工具可以识别出工程中哪些文件已经被修改，并且在再次编译的时候只编译这些 (修改的) 文件，从而提高编译的效率
> + make的主要任务是根据 Makefile 文件(一个脚本文件)中定义的规则和步骤，根据各个模块的更新情况，自动完成整个软件项目的维护和目标程序生成工作
> + make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎样去编译和链接程序
> + 叫 makefile 或者 Makefile 都可以，如果想用其它名称，需要使用 "-f" 选项来告诉make编译链接的规则写在哪个文件中 **make -f your_makefileName**

### 3. Makefile的基本规则
```make
target:dependencies
    commands

# target：目标，是一个文件或者合法的标识符
# dependencies：依赖，一个目标可以有很多依赖(也可以没有依赖)
# commands：命令，一条规则可以有许多条命令(也可以没有命令)
# 如果命令前面加上"@"，那么这条命令不会在终端中显示
```
+ 在Makefile中，第一条规则的目标将会成为终极目标，我们的最终目的就是生成这个目标
+ 其它规则之间没有必然的顺序关系
+ 当时间信息不对时，需要将时间信息调整正确之后，才能使用make命令
+ make是根据文件的时间信息来判断源文件是否需要重新编译的
+ 如果最终生成的文件(a.out)比所有文件都新(看文件的时间)，就认为工程代码没有改动，不需要重新编译；如果有一个文件的时间比a.out还新，就认为工程有改动，需要重新编译

## 二、Makefile变量赋值
**为什么要引入变量？**  
简单地说，你也不想一直写 a.c、b.c、c.c、d.c 吧，将这些 *.c 文件赋值给一个变量，下次用到的时候直接取变量的值就好了

### 变量赋值的方式
|赋值符号|含义|
|:----:|:----:|
|:=|[立即展开赋值](#立即展开赋值)|
|=|[延迟展开赋值](#延迟展开赋值)|
|?=|[条件赋值](#条件赋值)|
|+=|[追加赋值](#追加赋值)|

### 1. <span id="立即展开赋值">立即展开赋值</span>
```Makefile
B := $A
A = 10

instant:
    @echo "B = $B"
```
执行"make instant"会发现B并没有被赋值，这是因为用 := 给B赋值$A的时候，变量A还没有被赋值

### 2. <span id="延迟展开赋值">延迟展开赋值</span>
```Makefile
B = $A
A = 10

delay:
    @echo "B = $B"
```
执行"make delay"会发现终端打印 "B = 10"，这是因为用 = 给B赋值的时候，会等到变量A被赋值才会给B赋值，这就是所谓的延时

### 3. <span id="条件赋值">条件赋值</span>
```Makefile
B = $A
A = 10
C ?= $D
# E = 20
E ?= $A

if:
    @echo "C = $C"
    @echo "E = $E"
```
**E ?= $A 的含义**：如果 D 之前没有被赋值过，将 A 的值赋值给它，否则保持原来的值不变  
**执行的结果**：E = 10，因为 E 之前没有被赋值过，所以将变量A的值赋值给它，若去掉上面的注释，执行了 "E = 20"，这时 "E ?= $A" 是不起作用的，执行结果是 "E = 20"

### 4. <span id="追加赋值">追加赋值</span>
```Makefile
A = 10
E = 20
E += $A

append:
    @echo "E = $E"
```
这里的 += 不要理解成为C语言中的 += ，这里是追加的意思，将左边的值拼接到原来的值后面，执行的结果是"E = 20 10"

## 三、Makefile中的特殊变量
### 变量赋值的方式
|特殊变量|含义|
|:----:|:----:|
|$@|当前规则中的目标target|
|$^|当前规则中的所有依赖dependencies|
|$<|当前规则中的第一个依赖|
|$$|当前执行的进程编号|
|$*|模式规则中的所有 % 匹配的部分|
|$?|模式规则中所有比所在规则中的目标更新的文件组成的列表|

### 隐含规则
+ 在make中有一些隐含的的规则，使用 "**make -p**"可以查看
+ 如果我们没有在 Makefile 中显式地写明某些规则，那么 make 会去隐含规则中查询是否有生成这个规则的目标规则存在，如果存在就会调用，如果不存在就会报错

### 使用特殊符号简化Makefile
```Makefile
########## 定义变量 ##########
TARGET = main.out
SOURCE = main.c test.c
#OBJECT = main.o test.o
CC = gcc # 定义使用的编译器

## 使用特殊变量 $@ 和 $^ 来代替 $(TARGET) 和 $(OBJECT)
#$(TARGET):$(OBJECT)
#	$(CC) $^ -o $@

## $(SOURCE:.c=.o)表示的是SOURCE中所有的 .c 文件生成的 .o 文件
$(TARGET):$(SOURCE:.c=.o)
	$(CC) $^ -o $@


## 模式规则：%会匹配 .c 文件前面的部分
## 模式规则执行时，是一个循环取出的过程，每次取出一个 .c ，调用下面的command，直到取出所有的 .c 文件
%.o:%.c
	$(CC) $< -c

clean:
#	rm -f $(TARGET) $(OBJECT)
	rm -f $(TARGET) $(SOURCE:.c=.o)
```

### 指定头文件的位置
```Makefile
############################## 定义变量 ##############################
TARGET = main.out
SOURCE = main.c test.c foo.c
## 使用交叉编译的时候打开下面的注释
# CROSS_COMPILER = arm-linux- # 定义交叉编译器
CC = $(CROSS_COMPILER)gcc # 定义使用的编译器

## 找到头文件的位置
CUR_DIR = $(shell pwd)
HEAD_DIR = $(CUR_DIR)/inc

## 定义 $(CC) 的编译选项
CCFLAGS = -I $(HEAD_DIR)

## $(SOURCE:.c=.o)表示的是SOURCE中所有的 .c 文件生成的 .o 文件
$(TARGET): $(SOURCE:.c=.o)
	$(CC) $^ $(CCFLAGS) -o $@

## 模式规则：%会匹配 .c 文件前面的部分
%.o: %.c
	$(CC) $< $(CCFLAGS) -c

## 下面的规则用来说明头文件的更新，使得所有依赖它的文件被重新生成
## 这里的 .d 文件是随意指定的，表示用 .c 文件生成对应的 .d 文件
## "> $@" 表示将 $(CC) -MM $< 执行的结果重定向到 $@ 中，$@ 是对应的 .d 文件
%.d: %.c
	$(CC) -MM $(CCFLAGS) $< > $@

## 下面的命令用来告诉make，将上面的模式规则中的命令执行结果包含进当前文件
#include $(SOURCE:.c=.d)
#-include $(SOURCE:.c=.d)
include $(SOURCE:.c=.d) # 这三行命令作用一样，推荐使用这种
## 这里的include会展开成,这些展开的内容变成新的规则
## foo.o: foo.c
## test.o: test.c
## main.o: main.c ./inc/all.h

## 清理中间文件和最终文件
clean:
	rm -vf $(TARGET) $(SOURCE:.c=.o) $(SOURCE:.c=.d)

## PHONY 后面的东西会被声明成伪目标
## 伪目标：不是真正的目标，仅仅是为了执行其所在规则下面的命令，不应该让make来判断它是否存在，或者应该被生成
## 一般将伪目标叫做标签，真正生成东西的叫目标
.PHONY: clean
```